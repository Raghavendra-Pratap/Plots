/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VaultIgnorePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  ignorePatterns: [
    "**/node_modules/**",
    "**/.git/**",
    "**/dist/**",
    "**/build/**",
    "**/target/**",
    "**/venv/**",
    "**/__pycache__/**",
    "**/bounding-box-plotter-backup/**",
    "**/conflicting-apps-backup/**",
    "**/global-node-modules-backup/**",
    "**/electron-bundle/**",
    "**/tmp_playground/**",
    "**/.DS_Store",
    "**/Thumbs.db",
    "**/*.pyc",
    "**/*.pyo",
    "**/*.pyd",
    "**/*.rlib",
    "**/*.rmeta",
    "**/*.egg-info/**",
    "**/*.egg",
    "**/*.dmg",
    "**/*.exe",
    "**/*.AppImage",
    "**/*.deb",
    "**/*.rpm"
  ],
  ignoreExtensions: [
    ".log",
    ".tmp",
    ".temp",
    ".cache",
    ".lock",
    ".pyc",
    ".pyo",
    ".pyd",
    ".so",
    ".rlib",
    ".rmeta",
    ".egg",
    ".dmg",
    ".exe",
    ".AppImage",
    ".deb",
    ".rpm",
    ".tgz",
    ".tar.gz",
    ".zip",
    ".rar",
    ".db",
    ".sqlite",
    ".sqlite3",
    ".pid",
    ".seed",
    ".bak",
    ".backup"
  ],
  ignoreKeywords: [
    "backup",
    "temp",
    "temporary",
    "cache",
    "debug",
    "build",
    "dist",
    "target",
    "venv",
    "__pycache__",
    "node_modules",
    "coverage",
    "pytest",
    "tox",
    "hypothesis",
    "nosetests",
    "egg-info",
    "updates",
    "update"
  ],
  ignoreFolders: [
    "node_modules",
    ".git",
    "dist",
    "build",
    "target",
    "venv",
    "env",
    "__pycache__",
    ".pytest_cache",
    ".coverage",
    "htmlcov",
    ".tox",
    ".cache",
    ".hypothesis",
    "bounding-box-plotter-backup",
    "conflicting-apps-backup",
    "global-node-modules-backup",
    "electron-bundle",
    "tmp_playground",
    "myScripts",
    "data_processing_output",
    "updates",
    ".obsidian"
  ],
  enableFileExplorerFiltering: true,
  enableSearchExclusion: true,
  enableObsidianIgnoreFile: true,
  obsidianIgnoreFilePath: ".obsidianignore"
};
var VaultIgnorePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.obsidianIgnorePatterns = [];
    this.ignoreFileWatcher = null;
  }
  async onload() {
    await this.loadSettings();
    await this.loadObsidianIgnorePatterns();
    this.addSettingTab(new VaultIgnoreSettingTab(this.app, this));
    this.initializeIgnoreFunctionality();
    this.addCommand({
      id: "toggle-vault-ignore",
      name: "Toggle Vault Ignore",
      callback: () => {
        this.toggleIgnoreFunctionality();
      }
    });
    this.addCommand({
      id: "refresh-ignore-patterns",
      name: "Refresh Ignore Patterns",
      callback: () => {
        this.refreshIgnorePatterns();
      }
    });
    this.setupIgnoreFileWatcher();
  }
  onunload() {
    if (this.ignoreFileWatcher) {
      this.app.vault.offref(this.ignoreFileWatcher);
    }
    this.restoreOriginalFunctionality();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadObsidianIgnorePatterns() {
    if (!this.settings.enableObsidianIgnoreFile) {
      this.obsidianIgnorePatterns = [];
      return;
    }
    try {
      const ignoreFile = this.app.vault.getAbstractFileByPath(this.settings.obsidianIgnoreFilePath);
      if (ignoreFile && ignoreFile instanceof import_obsidian.TFile) {
        const content = await this.app.vault.read(ignoreFile);
        this.obsidianIgnorePatterns = content.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
      } else {
        this.obsidianIgnorePatterns = [];
      }
    } catch (error) {
      console.error("Error loading .obsidianignore patterns:", error);
      this.obsidianIgnorePatterns = [];
    }
  }
  initializeIgnoreFunctionality() {
    if (this.settings.enableFileExplorerFiltering) {
      this.patchFileExplorer();
    }
    if (this.settings.enableSearchExclusion) {
      this.patchSearch();
    }
  }
  patchFileExplorer() {
    var _a;
    const fileExplorer = (_a = this.app.workspace.getLeavesOfType("file-explorer")[0]) == null ? void 0 : _a.view;
    if (fileExplorer) {
      this.originalFileExplorer = {
        createFileTree: fileExplorer.createFileTree,
        shouldShowFile: fileExplorer.shouldShowFile
      };
      if (fileExplorer.createFileTree) {
        const originalCreateFileTree = fileExplorer.createFileTree.bind(fileExplorer);
        fileExplorer.createFileTree = (folder) => {
          const tree = originalCreateFileTree(folder);
          return this.filterFileTree(tree);
        };
      }
      if (fileExplorer.shouldShowFile) {
        const originalShouldShowFile = fileExplorer.shouldShowFile.bind(fileExplorer);
        fileExplorer.shouldShowFile = (file) => {
          if (this.isFileIgnored(file)) {
            return false;
          }
          return originalShouldShowFile(file);
        };
      }
    }
  }
  patchSearch() {
    const searchPlugin = this.app.plugins.plugins["global-search"];
    if (searchPlugin) {
      this.originalSearch = {
        search: searchPlugin.search
      };
      const originalSearch = searchPlugin.search.bind(searchPlugin);
      searchPlugin.search = (query, options) => {
        const results = originalSearch(query, options);
        if (results && results.results) {
          results.results = results.results.filter((result) => {
            if (result.file && this.isFileIgnored(result.file)) {
              return false;
            }
            return true;
          });
        }
        return results;
      };
    }
  }
  filterFileTree(tree) {
    if (!tree)
      return tree;
    if (tree.children) {
      tree.children = tree.children.filter((child) => {
        if (child.file && this.isFileIgnored(child.file)) {
          return false;
        }
        if (child.folder && this.isFolderIgnored(child.folder)) {
          return false;
        }
        if (child.children) {
          child.children = this.filterFileTree(child).children;
        }
        return true;
      });
    }
    return tree;
  }
  isFileIgnored(file) {
    const path = (0, import_obsidian.normalizePath)(file.path);
    for (const pattern of this.settings.ignorePatterns) {
      if (this.matchesPattern(path, pattern)) {
        return true;
      }
    }
    for (const ext of this.settings.ignoreExtensions) {
      if (file.extension === ext.substring(1)) {
        return true;
      }
    }
    for (const keyword of this.settings.ignoreKeywords) {
      if (file.name.toLowerCase().includes(keyword.toLowerCase())) {
        return true;
      }
    }
    if (this.settings.enableObsidianIgnoreFile) {
      return this.checkObsidianIgnoreFile(file);
    }
    return false;
  }
  isFolderIgnored(folder) {
    const path = (0, import_obsidian.normalizePath)(folder.path);
    for (const pattern of this.settings.ignorePatterns) {
      if (this.matchesPattern(path, pattern)) {
        return true;
      }
    }
    for (const ignoreFolder of this.settings.ignoreFolders) {
      if (folder.name === ignoreFolder || path.includes(ignoreFolder)) {
        return true;
      }
    }
    for (const keyword of this.settings.ignoreKeywords) {
      if (folder.name.toLowerCase().includes(keyword.toLowerCase())) {
        return true;
      }
    }
    return false;
  }
  matchesPattern(path, pattern) {
    const regexPattern = pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\?/g, "[^/]").replace(/\./g, "\\.");
    const regex = new RegExp("^" + regexPattern + "$");
    return regex.test(path);
  }
  checkObsidianIgnoreFile(file) {
    for (const pattern of this.obsidianIgnorePatterns) {
      if (this.matchesPattern(file.path, pattern)) {
        return true;
      }
    }
    return false;
  }
  toggleIgnoreFunctionality() {
    this.settings.enableFileExplorerFiltering = !this.settings.enableFileExplorerFiltering;
    this.settings.enableSearchExclusion = !this.settings.enableSearchExclusion;
    this.saveSettings();
    this.refreshIgnorePatterns();
  }
  async refreshIgnorePatterns() {
    var _a;
    await this.loadObsidianIgnorePatterns();
    this.restoreOriginalFunctionality();
    this.initializeIgnoreFunctionality();
    const fileExplorer = (_a = this.app.workspace.getLeavesOfType("file-explorer")[0]) == null ? void 0 : _a.view;
    if (fileExplorer && fileExplorer.requestSort) {
      fileExplorer.requestSort();
    }
  }
  restoreOriginalFunctionality() {
    var _a;
    const fileExplorer = (_a = this.app.workspace.getLeavesOfType("file-explorer")[0]) == null ? void 0 : _a.view;
    if (fileExplorer && this.originalFileExplorer) {
      if (this.originalFileExplorer.createFileTree) {
        fileExplorer.createFileTree = this.originalFileExplorer.createFileTree;
      }
      if (this.originalFileExplorer.shouldShowFile) {
        fileExplorer.shouldShowFile = this.originalFileExplorer.shouldShowFile;
      }
    }
    const searchPlugin = this.app.plugins.plugins["global-search"];
    if (searchPlugin && this.originalSearch) {
      searchPlugin.search = this.originalSearch.search;
    }
  }
  setupIgnoreFileWatcher() {
    if (!this.settings.enableObsidianIgnoreFile) {
      return;
    }
    this.ignoreFileWatcher = this.app.vault.on("modify", (file) => {
      if (file.path === this.settings.obsidianIgnoreFilePath) {
        this.loadObsidianIgnorePatterns();
      }
    });
  }
};
var VaultIgnoreSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Vault Ignore Settings" });
    new import_obsidian.Setting(containerEl).setName("Ignore Patterns").setDesc("Glob patterns for files and folders to ignore (one per line)").addTextArea((text) => text.setPlaceholder("**/node_modules/**\n**/.git/**\n**/dist/**").setValue(this.plugin.settings.ignorePatterns.join("\n")).onChange(async (value) => {
      this.plugin.settings.ignorePatterns = value.split("\n").filter((p) => p.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Ignore Extensions").setDesc("File extensions to ignore (one per line, with or without dot)").addTextArea((text) => text.setPlaceholder(".log\n.tmp\n.cache").setValue(this.plugin.settings.ignoreExtensions.join("\n")).onChange(async (value) => {
      this.plugin.settings.ignoreExtensions = value.split("\n").filter((e) => e.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Ignore Keywords").setDesc("Keywords in filenames to ignore (one per line)").addTextArea((text) => text.setPlaceholder("backup\ntemp\ncache").setValue(this.plugin.settings.ignoreKeywords.join("\n")).onChange(async (value) => {
      this.plugin.settings.ignoreKeywords = value.split("\n").filter((k) => k.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Ignore Folders").setDesc("Folder names to ignore (one per line)").addTextArea((text) => text.setPlaceholder("node_modules\n.git\ndist").setValue(this.plugin.settings.ignoreFolders.join("\n")).onChange(async (value) => {
      this.plugin.settings.ignoreFolders = value.split("\n").filter((f) => f.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable File Explorer Filtering").setDesc("Hide ignored files and folders from the file explorer").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableFileExplorerFiltering).onChange(async (value) => {
      this.plugin.settings.enableFileExplorerFiltering = value;
      await this.plugin.saveSettings();
      this.plugin.refreshIgnorePatterns();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Search Exclusion").setDesc("Exclude ignored files from search results").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSearchExclusion).onChange(async (value) => {
      this.plugin.settings.enableSearchExclusion = value;
      await this.plugin.saveSettings();
      this.plugin.refreshIgnorePatterns();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable .obsidianignore File").setDesc("Read ignore patterns from a .obsidianignore file in your vault root").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableObsidianIgnoreFile).onChange(async (value) => {
      this.plugin.settings.enableObsidianIgnoreFile = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName(".obsidianignore File Path").setDesc("Path to the ignore file (relative to vault root)").addText((text) => text.setPlaceholder(".obsidianignore").setValue(this.plugin.settings.obsidianIgnoreFilePath).onChange(async (value) => {
      this.plugin.settings.obsidianIgnoreFilePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Refresh Ignore Patterns").setDesc("Manually refresh the ignore patterns and reapply filtering").addButton((button) => button.setButtonText("Refresh").onClick(() => {
      this.plugin.refreshIgnorePatterns();
    }));
  }
};
